内存泄露对前端性能的影响是渐渐式且具有破坏性的，从细微卡顿到页面崩溃，都直接影响到用户体验。

## 内存泄漏的原因
- 事件监听相关泄露（最常见）
  - 未清理的 DOM 事件监听器
    - 为 DOM 元素绑定事件（如 click、scroll、resize）后，元素被移除或场景失效时，未调用 removeEventListener 解绑。
  - 全局事件未解绑
    - 为 window、document 等全局对象绑定事件（如 scroll、message）
- 定时器 / 异步任务相关泄露
  - 未清除的定时器（setInterval/setTimeout）
  - 未终止的异步请求 / 订阅
    - fetch/XHR 请求、WebSocket 连接、第三方订阅（如 EventBus）未在场景失效时终止。
- 闭包相关泄露
  - 闭包（如函数返回函数、定时器回调）引用了外部未使用的大对象、DOM 元素，导致这些资源无法被 GC 回收。
- DOM 相关泄露
  - 游离 DOM 节点（Detached DOM），DOM树中已经没有引用，但是js中还有引用
- 全局变量相关泄露
   - 意外创建的全局变量
    - 未声明的变量（如 a = 1 而非 let a = 1）、隐式全局变量（如函数内 this 指向 window）会挂载到 window 上，生命周期与页面一致。
   - 未清理的全局缓存 / 存储
    - window 上的全局缓存对象、单例模式中的静态属性，长期累积未清理的冗余数据。

## 按照性能恶化链路拆解为以下几个方面：
- 内存占用持续飙升，挤压系统资源
  - 内存泄漏导致无用资源（如未清除的定时器、废弃的DOM引用）无法被回收，内存占用随页面运行时间线性增长。这直接挤压浏览器的内存分配，当内存占用接近设备上限，浏览器会优先限制前端进程资源使用，导致代码执行效率下降。
- 页面卡顿，响应延迟
  - 随着内存占用的 升高，js引擎和浏览器渲染引擎运行效率降低。原本瞬时完成的DOM 操作开始“掉帧”
- 浏览器异样行为频发
  - 页面部分功能失效，浏览器标签页卡顿自动刷新
- 极端场景下，直接崩溃。

