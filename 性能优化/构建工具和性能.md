# 模块化规范
## commonjs
commonjs 通过 `require` 引入模块，`module.exports` 导出模块。

commonjs 是同步加载模块的

在服务端运行时没有问题，因为服务端从硬盘加载文件，非常快。

但是在浏览器端运行时，加载新的模块意味着网络传输，会阻塞页面渲染，导致页面卡顿。

不能让javascript阻塞在网络上，就产生了异步加载方案。

## AMD
AMD 是异步加载模块的，通过 `define` 定义模块，`require` 引入模块。

AMD 模块是在浏览器端运行的，加载模块时不会阻塞页面渲染。

当执行 `require` 时，如果已经定义了对应的模块，则直接加载里面的内容，如果不存在，则通过请求动态加载模块内容。

AMD 提倡提前声明和执行依赖，这意味着无论现在是否用到这个模块的逻辑，代码被  `require` 时，会先执行依赖模块的代码。

## CMD
CMD 是 seajs 提出的面向浏览器的模块化方案，相比AMD的依赖声明和提前执行依赖内容，CMD主张 在使用时执行依赖，这样CMD可以懒执行，在还未使用`require` 到对应模块时，不需要执行对应内容。

## 依赖加载优化
按照以上模块化的思路，都不可避免的会遇到深层次依赖的加载问题，也就是模块A依赖模块B，模块B依赖模块C，模块C依赖模块D。

单纯优化加载器无法解决这个问题，因为加载器只能按照模块的定义顺序加载模块，无法分析模块之间的依赖关系。

为了解决这个问题，就产生了依赖加载优化的方案。

从构建工具出发，构建工具可以分析模块之间的依赖关系，根据依赖关系生成优化后的模块加载顺序。最后把模块A依赖模块B，模块B依赖模块C，模块C依赖模块D的信息直接写到模块A中，A依赖【B、C、D】。

## 模块打包器
webpack核心功能就是模块打包，就是把一堆分散的模块文件打包成一个可执行的bundle.js文件。

## ESM
ESM 是浏览器的新规范，通过 `import` 引入模块，`export` 导出模块。

ESM 是异步加载模块的，加载模块时不会阻塞页面渲染。

ESM充分考虑了静态分析的需求，可以在不执行代码的情况下 分析导入导出内容。

# 构建工具可以干什么
随着模块化、打包器 成了前端的标配，在项目中 引用第三方依赖也越来越复杂。在中后台面临的一个很大的问题就是bundle体积太大，无论加载 还是执行都非常 耗时。
## 构建工具和构建优化
使用工具链在构建或者编译时改善构建产物的性能称为编译时优化或者静态优化。

javascript 作为一种必须由网络交付给用户才能执行的语言，优化体积的 效果远比其他编译时优化的效果更显著。
### 为什么优化体积
减小打包体积不仅是减少网络传输时间，javascript体积的背后还有一些比体积本身更难度量的性能影响
- CPU消耗
  - 解析
  - 编译
  - 执行
- 内存占用
## bundle 分析
在对bundle进行优化前，可以借助分析工具分析体积构成。

比如 webpack 提供的 [webpack-bundle-analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer) 插件，可以可视化展示 bundle 体积构成。

在treemap中可以清晰的看到每个模块的体积，以及模块之间的依赖关系。

##  Tree-Shaking
当引入一个npm包，整体打包体积显著增加，现在有专门用于计算npm包增加体积的->[网站](https://bundlephobia.com/)。

可以在网站中输入npm包的名称，查看该包的体积构成。

tree shaking 是一种优化技术，它可以在打包时 移除未使用的代码。

tree shaking 依赖于 ES6 模块的静态分析，只能移除未使用的导出内容，不能移除未使用的导入内容。

对于commonjs 模块，tree shaking 的静态分析不是很可靠。

##  scope hoisting
随着模块的数量 越多，这种模块化包裹的重复也越来越多，很多模块其实并没有被多个其他模块复用，模块化的 包裹就 增加了体积和运行时的成本。

前端构建时，可以采用把只被一个模块使用的模块直接展开到对应模块的Function 包裹中 ，这样就可以减少模块化包裹的数量，从而减少体积和运行时的成本。

scope hoisting 在webpack4 以上默认开启，仅启用 ESM；

开启这个之后，可以看到bundle中 模块化包裹的数量 减少了很多。

##  code splitting
bundle体积中，还包括大量的 代码并不一定会执行。比如 用户在一定的交互后 才会弹出 的弹窗。

这部分代码可以在执行特定逻辑后再动态加载，而不是全量打包到bundle中。

在webpack中通过静态分析，把不同模块打包到不同文件，将一开始不需要使用的模块放到动态加载的js文件中，加载时通过 jsonp 方式把模块加载到内存的模块列表中。

## 代码 压缩 
uglify、terser
### 精简表达
### 移除死代码
###  压缩css、html
