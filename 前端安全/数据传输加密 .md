核心思路
- 前端生成随机 AES 密钥（用于加密敏感数据，高效）
- 前端用后端提供的 RSA 公钥，加密 AES 密钥（保证密钥安全）
- 前端将「加密后的 AES 密钥 + 加密后的敏感数据」一起传给后端
- 后端用 RSA 私钥解密出 AES 密钥，再解密敏感数据

```js
import CryptoJS from 'crypto-js';
import JSEncrypt from 'jsencrypt';

/**
 * 前端加密工具类（AES+RSA 混合加密）
 * 无硬编码密钥，所有参数动态传入
 */
class EncryptUtil {
  /**
   * 生成随机字符串（用于 AES 密钥/IV/盐）
   * @param {number} length - 随机字符串长度
   * @returns {string} 随机字符串（字母+数字）
   */
  static generateRandomStr(length = 16) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
      result += chars[Math.floor(Math.random() * chars.length)];
    }
    return result;
  }

  /**
   * AES 加密（默认 GCM 模式，带认证标签）
   * @param {string|object} data - 待加密数据（对象会自动 JSON 序列化）
   * @param {string} aesKey - AES 密钥（建议 16/24/32 位）
   * @param {object} options - 加密选项
   * @param {string} options.mode - AES 模式（CBC/GCM，默认 GCM）
   * @param {string} [options.iv] - 初始化向量（不传入则自动生成，GCM 建议 12 位，CBC 建议 16 位）
   * @param {string} [options.salt] - 盐值（GCM 模式无需盐，CBC 可选）
   * @returns {object} 加密结果 { ciphertext: 密文, iv: 初始化向量, salt?: 盐值, authTag?: 认证标签 }
   */
  static aesEncrypt(data, aesKey, { mode = 'GCM', iv, salt } = {}) {
    // 序列化数据
    const plaintext = typeof data === 'object' ? JSON.stringify(data) : String(data);
    // 自动生成 IV（GCM 12位更安全，CBC 16位）
    const finalIv = iv || this.generateRandomStr(mode === 'GCM' ? 12 : 16);
    // 转换密钥/IV 为 CryptoJS 格式
    const key = CryptoJS.enc.Utf8.parse(aesKey);
    const ivCrypto = CryptoJS.enc.Utf8.parse(finalIv);

    let encryptResult;
    if (mode === 'GCM') {
      // GCM 模式（带认证标签，防篡改）
      encryptResult = CryptoJS.AES.encrypt(plaintext, key, {
        iv: ivCrypto,
        mode: CryptoJS.mode.GCM,
        padding: CryptoJS.pad.NoPadding, // GCM 模式无需填充
      });
      return {
        ciphertext: encryptResult.ciphertext.toString(CryptoJS.enc.Base64),
        iv: finalIv,
        authTag: encryptResult.getAuthTag().toString(CryptoJS.enc.Base64),
      };
    } else if (mode === 'CBC') {
      // CBC 模式（需填充，可选盐值）
      const finalSalt = salt || this.generateRandomStr(16);
      encryptResult = CryptoJS.AES.encrypt(plaintext, key, {
        iv: ivCrypto,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.PKCS7,
        salt: CryptoJS.enc.Utf8.parse(finalSalt),
      });
      return {
        ciphertext: encryptResult.ciphertext.toString(CryptoJS.enc.Base64),
        iv: finalIv,
        salt: finalSalt,
      };
    } else {
      throw new Error(`不支持的 AES 模式：${mode}`);
    }
  }

  /**
   * RSA 加密（公钥加密，用于加密 AES 密钥）
   * @param {string} data - 待加密数据（通常是 AES 密钥）
   * @param {string} rsaPublicKey - RSA 公钥（PEM 格式，带 -----BEGIN PUBLIC KEY----- 头尾）
   * @returns {string} 加密后的 Base64 字符串
   */
  static rsaEncrypt(data, rsaPublicKey) {
    if (!rsaPublicKey) throw new Error('RSA 公钥不能为空');
    const encryptor = new JSEncrypt();
    encryptor.setPublicKey(rsaPublicKey);
    // RSA 加密长度限制，分段加密（适配 2048/4096 位密钥）
    const maxLength = rsaPublicKey.includes('4096') ? 512 : 245;
    let result = '';
    for (let i = 0; i < data.length; i += maxLength) {
      const chunk = data.slice(i, i + maxLength);
      const encryptedChunk = encryptor.encrypt(chunk);
      if (!encryptedChunk) throw new Error('RSA 加密失败');
      result += encryptedChunk;
    }
    return btoa(result); // 二次 Base64 编码，避免特殊字符
  }

  /**
   * 混合加密（AES 加密数据 + RSA 加密 AES 密钥）
   * @param {string|object} data - 待加密敏感数据
   * @param {string} rsaPublicKey - RSA 公钥（后端提供）
   * @param {object} options - 加密选项
   * @param {string} [options.aesKey] - 自定义 AES 密钥（不传入则自动生成 16 位）
   * @param {string} [options.aesMode] - AES 模式（CBC/GCM，默认 GCM）
   * @returns {object} 最终传输对象（直接传给后端）
   * {
   *   encryptedAesKey: RSA 加密后的 AES 密钥,
   *   encryptedData: AES 加密后的密文,
   *   iv: AES 初始化向量,
   *   authTag?: GCM 模式认证标签,
   *   salt?: CBC 模式盐值
   * }
   */
  static hybridEncrypt(data, rsaPublicKey, { aesKey, aesMode = 'GCM' } = {}) {
    // 自动生成 AES 密钥（16 位 = AES-128，24 位 = AES-192，32 位 = AES-256）
    const finalAesKey = aesKey || this.generateRandomStr(16);
    // AES 加密数据
    const aesResult = this.aesEncrypt(data, finalAesKey, { mode: aesMode });
    // RSA 加密 AES 密钥
    const encryptedAesKey = this.rsaEncrypt(finalAesKey, rsaPublicKey);
    // 返回整合结果（后端需用这些参数解密）
    return {
      encryptedAesKey,
      encryptedData: aesResult.ciphertext,
      iv: aesResult.iv,
      ...(aesResult.authTag && { authTag: aesResult.authTag }),
      ...(aesResult.salt && { salt: aesResult.salt }),
    };
  }
}

// 导出使用（ESModule/CommonJS 兼容）
if (typeof module !== 'undefined' && module.exports) {
  module.exports = EncryptUtil;
} else {
  window.EncryptUtil = EncryptUtil;
}

export default EncryptUtil;
```