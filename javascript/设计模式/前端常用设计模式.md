# 一、创建型模式（专注 “对象创建”，解耦对象创建与使用）
## 1. 单例模式（Singleton）
确保一个类仅有一个实例，并提供全局访问点（避免重复创建资源浪费）。
```js
class Singleton {
    constructor() {
        if (!Singleton.instance) {
            Singleton.instance = this;
        }
        return Singleton.instance;
    }
}

```
```js
// Vue中应用（全局弹框/通知）
Vue.prototype.$notification = (() => {
  let instance = null;
  return {
    open: (options) => {
      if (!instance) {
        // 动态创建弹框组件
        const Notification = Vue.extend(require("./Notification.vue").default);
        instance = new Notification({ propsData: options }).$mount();
        document.body.appendChild(instance.$el);
      }
      instance.show(); // 复用实例
      return instance;
    }
  };
})();
```
### 适用场景：
- 全局弹框、通知组件（如 Element UI 的 $notify）；
- 工具类（如日志工具、请求工具，避免重复初始化）。

## 2. 工厂模式（Factory）
通过 “工厂方法” 统一创建对象，屏蔽对象创建的复杂逻辑，用户只需传入参数即可获取实例
```js
// 组件工厂：根据类型创建不同按钮组件
class ButtonFactory {
  // 静态工厂方法
  static createButton(type, props) {
    switch (type) {
      case "primary":
        return <PrimaryButton {...props} />;
      case "danger":
        return <DangerButton {...props} />;
      case "text":
        return <TextButton {...props} />;
      default:
        throw new Error(`不支持的按钮类型：${type}`);
    }
  }
}

// 组件定义（简化）
const PrimaryButton = (props) => <button className="primary" {...props} />;
const DangerButton = (props) => <button className="danger" {...props} />;
const TextButton = (props) => <button className="text" {...props} />;

// 使用：无需关心组件创建细节，仅传类型
function App() {
  return (
    <div>
      {ButtonFactory.createButton("primary", { onClick: () => alert("主按钮") })}
      {ButtonFactory.createButton("danger", { children: "危险按钮" })}
    </div>
  );
}
```
# 二、结构型模式（专注 “对象组合”，优化代码结构）
## 3. 代理模式（Proxy）
为目标对象提供 “代理”，控制对目标对象的访问（如权限校验、缓存、日志记录）
```js
// 目标对象：原始请求函数
const apiRequest = async (url) => {
  const res = await fetch(url);
  return res.json();
};

// 代理对象：添加缓存+日志功能
const requestProxy = (() => {
  const cache = new Map(); // 缓存存储

  return async (url) => {
    // 1. 缓存命中：直接返回缓存数据
    if (cache.has(url)) {
      console.log(`缓存命中：${url}`);
      return cache.get(url);
    }

    // 2. 日志记录
    console.log(`发起请求：${url}`);

    // 3. 转发请求到 **目标对象**
    const data = await apiRequest(url);

    // 4. 缓存结果（有效期5分钟）
    cache.set(url, data);
    setTimeout(() => cache.delete(url), 5 * 60 * 1000);

    return data;
  };
})();

// 使用：通过代理发起请求（透明调用）
requestProxy("https://api.xxx.com/data"); // 发起请求，记录日志
requestProxy("https://api.xxx.com/data"); // 缓存命中，不重复请求
```
## 4. 装饰器模式（Decorator）
不修改原对象，通过 “包装” 为对象添加新功能（比继承更灵活）。
```js
// 装饰器1：添加加载状态
function withLoading(Component) {
  return function DecoratedComponent({ isLoading, ...props }) {
    if (isLoading) {
      return <div>加载中...</div>;
    }
    return <Component {...props} />;
  };
}

// 装饰器2：添加错误处理
function withErrorBoundary(Component) {
  return class DecoratedComponent extends React.Component {
    state = { hasError: false };

    componentDidCatch(error) {
      this.setState({ hasError: true });
      console.error("组件报错：", error);
    }

    render() {
      if (this.state.hasError) {
        return <div>页面加载失败，请刷新重试</div>;
      }
      return <Component {...this.props} />;
    }
  };
}

// 原始组件
function DataList({ data }) {
  return <ul>{data.map(item => <li key={item.id}>{item.name}</li>)}</ul>;
}

// 装饰后组件：同时拥有加载状态和错误处理
const EnhancedDataList = withLoading(withErrorBoundary(DataList));

// 使用
function App() {
  const [isLoading, setIsLoading] = React.useState(true);
  const [data, setData] = React.useState([]);

  React.useEffect(() => {
    setTimeout(() => setIsLoading(false), 1000);
  }, []);

  return <EnhancedDataList isLoading={isLoading} data={data} />;
}
```
##  5. 适配器模式（Adapter）
将一个类的接口转换为另一个接口，解决 “接口不兼容” 问题（如新旧接口适配、第三方库接口适配）。

适用场景：
- 新旧系统迁移（前端不修改代码，通过适配器适配旧接口）；
- 第三方库适配（如将不同图表库的接口统一为自定义接口）；
- 跨端开发（如小程序 / APP 接口差异适配）。
```js
// 旧接口（后端老接口，返回格式不满足前端需求）
const oldApi = {
  getUserInfo: () => {
    return {
      u_name: "张三",
      u_age: 20,
      u_id: 1001
    };
  }
};

// 适配器：将旧接口格式转换为新接口格式
const apiAdapter = {
  getUserInfo: async () => {
    const oldData = await oldApi.getUserInfo();
    // 格式转换：旧字段 → 新字段
    return {
      name: oldData.u_name,
      age: oldData.u_age,
      id: oldData.u_id,
      // 新增前端需要的字段
      fullInfo: `${oldData.u_name}（${oldData.u_age}岁）`
    };
  }
};

// 使用：前端统一调用适配器接口，无需关心旧接口格式
apiAdapter.getUserInfo().then(data => {
  console.log(data); // { name: "张三", age: 20, id: 1001, fullInfo: "张三（20岁）" }
});
```
# 三、行为型模式（专注 “对象交互”，优化代码逻辑流转）
## 6. 观察者模式（Observer）
定义 “一对多” 依赖关系，当一个对象（被观察者）状态变化时，所有依赖它的对象（观察者）自动收到通知并更新。
观察者模式：观察者与被观察者 “互相认识”
被观察者（Subject）内部维护一个观察者（Observer）列表，观察者必须注册到被观察者中才能接收通知；
双方耦合度高：被观察者知道要通知哪些观察者，观察者也知道自己订阅了哪个被观察者；
一旦被观察者或观察者修改，可能需要联动修改对方。
```js
//  被观察者 subject
class  Subject {
    constructor() {
        this.observers = []; // 订阅者数组
    }
    addObserve(observer) {
        this.observers.push(observer);
    }
    // 通知所有订阅者
    notify(data) {
        this.observers.forEach(observer => observer.update(data));
    }
}

class  Observer {
    constructor(name) {
        this.name = name;
        this.update = (data) => {
            console.log(`${this.name} 收到通知：${data}`);
        };
    }
}

// 使用：双方直接关联
const subject = new Subject(); // 被观察者
const observer1 = new Observer("观察者1");  // 观察者1
const observer2 = new Observer("观察者2"); // 观察者2

subject.addObserve(observer1);
subject.addObserve(observer2);

subject.notify("状态更新了"); 
```
## 7. 发布 - 订阅模式（Publish/Subscribe）
观察者模式的 “解耦升级版”，通过 “事件中心” 连接发布者和订阅者，两者无需知道对方存在（比观察者模式更灵活）。
```js
// 发布-订阅模式：全局事件中心（与观察者模式的区别：事件中心统一管理）
class PubSub {
  constructor() {
    this.topics = new Map(); // key=主题，value=订阅者回调数组
  }

  // 订阅主题
  subscribe(topic, callback) {
    if (!this.topics.has(topic)) {
      this.topics.set(topic, []);
    }
    this.topics.get(topic).push(callback);
    // 返回取消订阅函数
    return () => this.unsubscribe(topic, callback);
  }

  // 发布主题
  publish(topic, ...args) {
    if (this.topics.has(topic)) {
      // 复制回调数组，避免订阅者在回调中取消订阅导致遍历异常
      [...this.topics.get(topic)].forEach(callback => callback(...args));
    }
  }

  // 取消订阅
  unsubscribe(topic, callback) {
    if (this.topics.has(topic)) {
      const callbacks = this.topics.get(topic);
      this.topics.set(
        topic,
        callbacks.filter(cb => cb !== callback)
      );
    }
  }
}

// 全局实例
const pubSub = new PubSub();

// 订阅者（无需知道发布者）
const unsubscribe = pubSub.subscribe("orderSuccess", (orderId) => {
  console.log(`订单${orderId}支付成功，发送通知`);
});

// 发布者（无需知道订阅者）
pubSub.publish("orderSuccess", "OD123456");

// 取消订阅
unsubscribe();
```
## 8. 策略模式（Strategy）
定义一系列算法，将每个算法封装起来，并且使它们可互换（根据场景动态切换算法，避免大量 if-else）
```js
// 策略集合：封装不同的验证规则
const validationStrategies = {
  // 非空验证
  required: (value, message) => {
    if (!value || value.trim() === "") return message;
  },
  // 手机号验证
  phone: (value, message) => {
    const reg = /^1[3-9]\d{9}$/;
    if (!reg.test(value)) return message;
  },
  // 长度验证
  minLength: (value, length, message) => {
    if (value.length < length) return message;
  }
};

// 上下文：使用策略的统一入口
class Validator {
  constructor() {
    this.rules = []; // 存储验证规则
  }

  // 添加验证规则
  add(value, rules) {
    rules.forEach(rule => {
      const { strategy, message, length } = rule;
      // 绑定策略函数
      this.rules.push(() => {
        return validationStrategies[strategy](value, length, message);
      });
    });
  }

  // 执行验证
  validate() {
    for (const rule of this.rules) {
      const errorMsg = rule();
      if (errorMsg) return errorMsg; // 验证失败，返回错误信息
    }
    return ""; // 验证通过
  }
}

// 使用：动态切换验证策略，无 if-else
function validateForm(formData) {
  const validator = new Validator();

  // 用户名验证：非空 + 最小长度3
  validator.add(formData.username, [
    { strategy: "required", message: "用户名不能为空" },
    { strategy: "minLength", length: 3, message: "用户名至少3个字符" }
  ]);

  // 手机号验证：非空 + 手机号格式
  validator.add(formData.phone, [
    { strategy: "required", message: "手机号不能为空" },
    { strategy: "phone", message: "手机号格式错误" }
  ]);

  return validator.validate();
}

// 调用验证
const formData = { username: "zh", phone: "123" };
const error = validateForm(formData);
console.log(error); // 用户名至少3个字符
```
## 9. 命令模式（Command）
将 “请求” 封装为对象，使请求的发送者和接收者解耦（支持请求排队、撤销 / 重做）。
```js
//实现代码（撤销 / 重做功能

// 接收者：实际执行操作的对象（如文档编辑）
class Document {
  constructor() {
    this.content = "";
  }

  // 追加内容
  append(text) {
    this.content += text;
    return this.content;
  }

  // 撤销最后一次追加
  undoAppend(text) {
    this.content = this.content.slice(0, -text.length);
    return this.content;
  }
}

// 命令接口：封装请求
class Command {
  constructor(receiver) {
    this.receiver = receiver; // 接收者
    this.param = null; // 命令参数
  }

  // 执行命令（子类实现）
  execute() {}

  // 撤销命令（子类实现）
  undo() {}
}

// 具体命令：追加内容命令
class AppendCommand extends Command {
  constructor(receiver, text) {
    super(receiver);
    this.param = text;
  }

  execute() {
    return this.receiver.append(this.param);
  }

  undo() {
    return this.receiver.undoAppend(this.param);
  }
}
// 调用者：管理命令队列，负责发送命令
class Editor {
    constructor() {
        this.commandQueue = []; // 命令队列
        this.currentIndex = -1; // 当前命令索引（用于撤销/重做）
    }

    // 执行命令
    executeCommand(command) {
        // 清空当前索引后的命令（避免重做时混乱）
        this.commandQueue.splice(this.currentIndex + 1);
        this.commandQueue.push(command);
        this.currentIndex++;
        return command.execute();
    }

    // 撤销命令
    undo() {
        if (this.currentIndex < 0) return;
        const command = this.commandQueue[this.currentIndex];
        this.currentIndex--;
        return command.undo();
    }

    // 重做命令
    redo() {
        if (this.currentIndex >= this.commandQueue.length - 1) return;
        this.currentIndex++;
        const command = this.commandQueue[this.currentIndex];
        return command.execute();
    }
}

// 使用：实现文档编辑的撤销/重做
const document = new Document();
const editor = new Editor();

// 执行命令
editor.executeCommand(new AppendCommand(document, "Hello ")); // content: "Hello "
editor.executeCommand(new AppendCommand(document, "World")); // content: "Hello World"

// 撤销
editor.undo(); // content: "Hello "

// 重做
editor.redo(); // content: "Hello World"

```
## 10. 迭代器模式（Iterator）

```js
// 迭代器接口：定义遍历方法
class Iterator {
  constructor(aggregate) {
    this.aggregate = aggregate; // 聚合对象
    this.index = 0; // 当前索引
  }

  // 是否有下一个元素
  hasNext() {}

  // 获取下一个元素
  next() {}
}

// 具体迭代器：遍历对象（支持按key/value遍历）
class ObjectIterator extends Iterator {
  constructor(aggregate, type = "key") {
    super(aggregate);
    this.type = type; // 遍历类型：key/value/entry
    this.keys = Object.keys(aggregate);
  }

  hasNext() {
    return this.index < this.keys.length;
  }

  next() {
    const key = this.keys[this.index];
    this.index++;
    switch (this.type) {
      case "key":
        return key;
      case "value":
        return this.aggregate[key];
      case "entry":
        return [key, this.aggregate[key]];
      default:
        throw new Error(`不支持的遍历类型：${this.type}`);
    }
  }
}

// 聚合对象：提供获取迭代器的方法
class ObjectAggregate {
  constructor(data) {
    this.data = data;
  }

  // 获取迭代器
  getIterator(type) {
    return new ObjectIterator(this.data, type);
  }
}

// 使用：统一遍历对象，无需关心内部结构
const user = { id: 1, name: "张三", age: 20 };
const aggregate = new ObjectAggregate(user);

// 遍历key
const keyIterator = aggregate.getIterator("key");
while (keyIterator.hasNext()) {
  console.log(keyIterator.next()); // id → name → age
}

// 遍历value
const valueIterator = aggregate.getIterator("value");
while (valueIterator.hasNext()) {
  console.log(valueIterator.next()); // 1 → 张三 → 20
}
```