# 一、核心架构：Options API 设计
- 设计理念：以配置选项组织组件的逻辑，将数据、方法、计算属性、生命周期封装为固定选项，降低门槛，符合声明式编程思想。
- 底层支撑：
  - 组件实例初始化时，Vue会将 Options 选项合并为实例 属性 ，如 this.data、this.methods 等。并通过属性代理让  this.xxx 直接访问 data、methods ，本质上是 this._data.xxx 或 this._methods.xxx。
  - 选项合并规则：组件自身  > mixin > 全局选项
# 二、响应式系统：Object.defineProperty 实现
- 核心逻辑：通过 劫持对象属性的 getter、setter 实现依赖收集与更新，核心模块是 Observer，Dep，Watcher 三者联动。
```js
// 简化核心代码
class Observer {
  constructor(value) {
    this.value = value;
    this.walk(value); // 遍历对象属性，转化为响应式
  }
  walk(obj) {
    Object.keys(obj).forEach(key => defineReactive(obj, key, obj[key]));
  }
}
function defineReactive(obj, key, val) {
  const dep = new Dep(); // 依赖收集器
  // 递归处理嵌套对象
  let childOb = observe(val);
  Object.defineProperty(obj, key, {
    get() {
      // 依赖收集：Watcher 访问属性时，将自身加入 Dep
      if (Dep.target) dep.depend();
      // 嵌套对象的依赖传递（如 obj.a.b，b 的 Dep 需关联 a 的 Watcher）
      if (childOb) childOb.dep.depend();
      return val;
    },
    set(newVal) {
      if (newVal === val) return;
      val = newVal;
      childOb = observe(newVal); // 新值转为响应式
      dep.notify(); // 通知所有 Watcher 更新
    }
  });
}
```
- 三大核心模块：
  - Observer：递归遍历data中的对象、数组，将属性转化为响应式（数组通过改写push、pop等方法实现响应式）
  - Dep：依赖收集器，每个响应式属性 对应 一个Dep，subs 数组存储相关联的 Watcher，提供 depend 方法 用于添加依赖（Watcher），notify 方法 用于通知 Watcher 更新。
  - Watcher：观察者，分为渲染 Watcher 和 计算属性 Watcher、用户Watcher（自定义watcher），核心方法update 触发组件重新渲染或回调执行。
-  依赖收集 与 更新流程 
  - 1、组件 初始化时，创建渲染watcher ，执行render函数
  - 2、 render函数访问data属性，触发getter，将当前的watcher加入 Dep 的  subs
  - 3、数据变化时，触发  setter，Dep  调用 notify ，遍历 subs 执行 Watcher的 update
  - 4、Watcher 触发组件的 patch过程（虚拟DOM对比、更新真实DOM），重新渲染组件。

- 设计局限
  - 1、无法监听对象新增、删除属性（Object.defineProperty 只能劫持已存在的属性）
  - 2、无法监听数组变化（如 push、pop 等方法），需通过重写数组方法实现响应式。
  - 3、嵌套对象需要递归遍历，性能开销随层级增加而线性增加。
  - 4、响应式对象需要提前声明，动态添加的属性需要 通过 Vue.set 或 this.$set 方法添加，才能成为响应式属性。

# 三、虚拟 DOM 与 diff 算法
- 虚拟DOM的作用
  - 抽象真实DOM为VNode对象（包含 tag、props、children、key等属性），避免频繁操作真实DOM，通过批量更新和差异化更新提升 性能。
- diff算法核心
  - 1、策略 ：同层比较（不跨层级 对比），因为实际开发中跨层级的DOM操作极少，性价比低
  - 2、流程：
    - 2.1、根节点 类型不同：直接销毁旧的VNode，创建新的VNode并挂载
    - 2.2、根节点 类型相同：对比 属性（patch props，更新 attrs、class、style、events）再递归对比子节点 
    - 2.3、列表diff：通过key建立新旧节点的映射关系，采用先对比 同key  节点，再移动、新增、删除的逻辑，避免不必要的节点重建， key不建议用 索引，会导致节点复用错误。
# 四、模板编译流程
Vue2是 模板--AST ---渲染函数的过程 ，核心在 vue-template-complier模块
- 步骤1：解析 Parse：将模板字符串转化为AST，识别指令、插值标签 
- 步骤2：优化 Optimize： 标记AST中静态节点（如纯文本、无动态绑定的标签）后续diff时，直接跳过这些节点，减少对比开销。
- 步骤3：生成 Generate：将优化后的AST转化为渲染函数 render，执行后生成VNode，再通过patch转化为真实的DOM
# 五、生命周期核心逻辑
本质：组件实例从创建到销毁的钩子回调序列
- 初始化阶段：
  - 1、beforeCreate：实例初始化完成，数据观测和事件配置之前调用，不能访问 this 上的数据和方法。
  - 2、created：实例创建完成，数据观测和事件配置完成，不能访问 DOM 元素。
- 挂载阶段：
  - 3、beforeMount：模板编译完成，挂载前调用，不能访问 DOM 元素。
  - 4、mounted：实例挂载完成，DOM 元素渲染完成，可访问和操作 DOM 元素。
- 更新阶段：
  - 5、beforeUpdate：数据更新前调用，可访问更新前的 DOM 状态。
  - 6、updated：数据更新后调用，DOM 已更新，可访问更新后的 DOM 状态。
- 销毁阶段：
  - 7、beforeDestroy：实例销毁前调用，可进行一些清理操作。
  - 8、destroyed：实例销毁后调用，所有事件监听器和子实例也会被调用。