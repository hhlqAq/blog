# 一、 核心架构：Composition API 设计
- 重构动机
  - 解决 Vue2 Options API 的痛点 —— 逻辑复用依赖 mixin，命名冲突，逻辑分散，复杂组件中逻辑按选项拆分（如数据处理和事件回调分散在不同选项），类型支持差（TS适配繁琐）
- 设计理念
  - 以函数组合组织逻辑，将组件逻辑拆分为独立的组合函数，逻辑可以自由组合、复用，类型友好
- 底层支撑
  - setup函数：组件初始化的入口，在 beforeCreate钩子之前执行，返回的属性、方法会暴露给模板和组件实例。
  - 响应式api按需导入：ref、reactive、computed、watch等可以直接导入，无需依赖Options选项
  - 上下文暴露：setup接收两个参数：props（组件属性）和context（上下文对象），可以在setup中使用props和context对象。替代了Vue2中this的使用。
# 二、响应式系统：Proxy 重构
- 重构动机：解决Vue2中 Object.defineProperty 的局限性 ，实现“原生支持对象新增、删除属性、数组下标修改，Map、Set等集合类型。”
- 核心逻辑
  - 通过ES6的Proxy代理整个对象而非单个属性，配合Reflect反射实现属性劫持，核心模块是 reactive、ref、effect
```js
// 简化核心代码
function reactive(target) {
  return new Proxy(target, {
    get(target, key, receiver) {
      const res = Reflect.get(target, key, receiver);
      track(target, key); // 依赖收集：关联 effect
      // 自动解包 ref（如 reactive({ a: ref(1) }) 可通过 obj.a 访问）
      return isRef(res) ? res.value : res;
    },
    set(target, key, value, receiver) {
      const oldValue = Reflect.get(target, key, receiver);
      const res = Reflect.set(target, key, isRef(value) ? value.value : value, receiver);
      if (oldValue !== value) {
        trigger(target, key); // 触发依赖更新
      }
      return res;
    },
    deleteProperty(target, key) {
      const existed = Reflect.has(target, key);
      const res = Reflect.deleteProperty(target, key);
      if (existed) {
        trigger(target, key); // 删除属性也触发更新
      }
      return res;
    }
  });
}
// 副作用函数：依赖响应式数据的函数（如渲染函数、watch 回调）
function effect(fn, options = {}) {
  const effectFn = () => {
    cleanup(effectFn); // 清除旧依赖，避免重复触发
    activeEffect = effectFn;
    fn(); // 执行函数，触发 get 劫持，收集依赖
  };
  effectFn.deps = []; // 存储关联的依赖
  if (options.lazy) return effectFn; // 懒执行（如 computed）
  effectFn();
}
```
- 核心 API 区别
  - reactive: 代理对象类型，深层响应式（嵌套对象自动转为 reactive）
  - ref： 包装基本类型 number、string、boolean 等，提供 .value 属性访问和响应式更新
  - Computed：基于 effect 实现，懒执行+缓存，依赖变化时才重新计算
  - watch：基于 effect 实现，支持监听单个、多个响应式数据，支持深度监听，立即执行等配置。
- 优势
  - 支持对象 新增 、删除属性，数组下标、长度修改。
  - 支持 Map、Set、WeakMap、WeakSet 等集合类型。
  - 嵌套对象 代理时，只在访问时递归代理（懒代理），性能更好。
  - 无需 手动 调用 vue.set
# 三、虚拟 DOM 与 diff 算法优化
核心优化点：Vue3 对 diff 算法的优化围绕 “减少对比次数” 和 “减少 DOM 操作”：
- 静态标记（PatchFlags）：编译时，标记VNode的 动态部分（如动态 文本，动态属性，动态子节点），diff时只对比 标记的动态部分 ，跳过静态节点。
```js
// 编译后带 PatchFlags 的 VNode（示例）
createVNode('div', { id: 'app' }, [
  createVNode('p', null, '静态文本'), // 无标记，diff 跳过
  createVNode('span', { class: reactiveClass }, null, PatchFlags.CLASS) // 只对比 class
]);
```
- 最长递增子序列: 列表diff时，通过最长递增子序列算法，确定无需移动的节点，减少节点移动次数
- 静态 提升 ：将 静态 的VNode 提升到 渲染函数外部，避免每次渲染重新创建 （减少内存分配 ）
- patchflag细分：动态部分细分为 TEXT/CLASS/STYLE/PROPS 等类型，diff 时只对比对应类型的属性，进一步减少开销。
# 四、编译时优化（Vue3 性能核心）
Vue3 性能提升的关键之一是 “编译时优化”，通过 @vue/compiler-core 对模板进行深度优化：
优化 1：静态提升（如静态节点、静态属性提升到渲染函数外部）；
优化 2：PatchFlags 标记（如上述 diff 优化）；
优化 3：树结构打平（嵌套的静态节点会被打平为单个静态节点，减少 VNode 层级）；
优化 4：v-once 优化（静态节点自动标记为 PatchFlags.STABLE，后续 diff 直接复用）；
优化 5：指令编译优化（如 v-if/v-for 优先级调整，v-for 在外时避免重复判断 v-if）。
#  五、生命周期与兼容性
Composition API 形式：onMounted/onUpdated/onUnmounted 等，需导入后在 setup 中使用；
