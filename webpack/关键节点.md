# plugin 的作用时机
插件通过监听 Compiler 生命周期钩子介入流程，比如：
- entry-option：入口配置处理后触发
- compile：编译开始前触发
- emit：产物输出前触发（可修改输出内容）
- done：构建完成后触发

# Loader 与 Plugin 区别：
- Loader 仅负责「模块代码转化」（如文件解析、语法转译）
- Plugin 负责「流程优化」（如代码分割、清空目录、注入资源）

|对比维度|Loader加载器|Plugin插件|
|--|--|--|
|核心定位|资源转换器（将非 JS/JSON 资源转为 Webpack 可识别模块）|构建流程扩展器（干预 / 增强 Webpack 全生命周期的构建能力）|
|作用对象|单个具体文件 / 模块（如 .css、.png、.ts）|整个构建流程（如编译、优化、输出、报错处理等阶段）|
|执行时机|模块构建阶段（compilation.buildModule 前后），早于 Plugin|全生命周期钩子（如 compiler.emit/compilation.optimizeAssets），覆盖构建全流程|
|核心职责|1. 非 JS 资源转译（如 TS→JS、Sass→CSS）<br>2. 单文件预处理（压缩、校验、注入）<br>3. 资源路径处理（如图片 URL 转换）|1. 产物优化（全量 JS/CSS/HTML 压缩）<br>2. 构建流程控制（清理输出目录、热更新）<br>3. 额外功能扩展（生成 HTML、注入环境变量）|
|配置方式|在 module.rules 中配置，通过 test 匹配文件，支持链式执行（从右到左）|在 plugins 数组中实例化，通过钩子监听构建事件，全局生效|
|执行逻辑|单一职责，一个 Loader 只处理一类资源 / 一个操作，依赖链式组合实现复杂需求|可跨资源 / 跨阶段处理，支持批量操作，逻辑灵活可扩展|
|影响范围|仅对匹配到的模块生效，不改变原文件内容|全局生效，可影响所有模块和构建流程|
|典型使用场景|按配置顺序执行，从右到左（如 babel-loader 先转译 ES6，再由 css-loader 处理 CSS 中的 url()）|按实例化顺序执行，无特定顺序要求|
|典型使用场景|1. 样式处理：sass-loader（Sass→CSS）、css-loader（解析 CSS 依赖）<br>2. 脚本转译：babel-loader（ES6+→ES5）、ts-loader（TS→JS）<br>3. 资源处理：image-webpack-loader（图片压缩）、url-loader（小图转 Base64）<br>4. 代码校验：eslint-loader（构建时 ESLint 检查）|1. 产物优化：TerserPlugin（JS 压缩）、CssMinimizerPlugin（CSS 压缩）<br>2. 资源管理：HtmlWebpackPlugin（生成 HTML）、CleanWebpackPlugin（清理输出目录）<br>3. 流程控制：HotModuleReplacementPlugin（热更新）、DefinePlugin（注入环境变量）<br>4. 构建分析：BundleAnalyzerPlugin（产物分析）|
|核心区别总结|「管文件」：聚焦单个资源的 “转译 + 预处理”，是 Webpack 解析非 JS 资源的基础|「管流程」：聚焦整个构建的 “扩展 + 优化”，是 Webpack 功能增强的核心|